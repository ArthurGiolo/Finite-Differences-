# -*- coding: utf-8 -*-
"""Convecção - Diferenças Finitas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19UiqfP3H94-_1hDJsLX7Sacc_xp_f5fY

# Funções
"""

import os
import numpy as np
import imageio as im
from numba import njit
import matplotlib.pyplot as plt

# Função para o cálculo de u*
@njit
def u_prime(Nx, dx, Ny, dy, u, u_, v, dt, Pr):
    for i in range(1,Nx):
        for j in range(0,Ny):
            v__ = 0.25*(v[i,j+1] + v[i-1,j+1] + v[i,j] + v[i-1,j])
            R   = dt*(Pr*((u[i+1,j] - 2.0*u[i,j] + u[i-1,j])/(dx**2.0)
                + (u[i,j+1] - 2.0*u[i,j] + u[i,j-1])/(dy**2.0)) - (u[i,j]*((u[i+1,j] - u[i-1,j])/(2*dx))
                + v__*((u[i,j+1] - u[i,j-1])/(2*dy))))
            u_[i,j]  = u[i,j] + R

    # Condições de contorno de u*
    ## No plano x=0.0 e x=1.0
    u_[0,:]  = 0.0
    u_[-3,:] = 0.0

    ## No plano y=0.0 e y=1.0
    u_[:,-1] = -u_[:,0]
    u_[:,-2] = -u_[:,-3]

    return u_

# Função para o cálculo de v*
@njit
def v_prime(Nx, dx, Ny, dy, u, v, v_, T, dt, Pr, Ra):
    for i in range(0,Ny):
        for j in range(1,Nx):
            u__ = 0.25*(u[i+1,j] + u[i+1,j-1] + u[i,j] + u[i,j-1])
            R   = dt*(Pr*((v[i+1,j] - 2.0*v[i,j] + v[i-1,j])/(dx**2.0)
                + (v[i,j+1] - 2.0*v[i,j] + v[i,j-1])/(dy**2.0)) - (u__*((v[i+1,j] - v[i-1,j])/(2*dx))
                + v[i,j]*((v[i,j+1] - v[i,j-1])/(2*dy))) + 0.5*Ra*Pr*(T[i,j] + T[i,j-1]))
            v_[i,j]  = v[i,j] + R

    # Condições de contorno de v*
    ## No plano x=0.0 e x=1.0
    v_[-1,:]  = -v_[0,:]
    v_[-2,:] = -v_[-3,:]

    ## No plano y=0.0 e y=1.0
    v_[:,0]  = 0.0
    v_[:,-3] = 0.0

    return v_

# Função para cálculo de Theta
@njit
def Theta(Nx, dx, Ny, dy, u, v, v_, T, T_n, dt, Pr, Ra):
    # Cálculo de Theta
    for i in range(0,Nx):
        for j in range(0,Ny):
            R        = dt*(((T[i+1,j] - 2.0*T[i,j] + T[i-1,j])/(dx**2) + (T[i,j+1] - 2.0*T[i,j] + T[i,j-1])/(dy**2)) - ((0.5*(u[i,j+1] + u[i,j]))*((T[i+1,j] - T[i-1,j])/(2*dx)) + (0.5*(v[i,j] + v[i+1,j]))*((T[i,j+1] - T[i,j-1])/(2*dy))))
            T_n[i,j] = T[i,j] + R

    # Condições de contorno de Theta
    ## No plano x=0.0 e x=1.0
    T_n[-1,:]  = 2.0 - T_n[0,:]
    T_n[-3,:] = 0.0

    ## No plano y=0.0 e y=1.0
    T_n[:,-1]  =  T_n[:,0]
    T_n[:,-2] =  T_n[:,-3]

    return T_n

# Função para o cálculo da pressão
@njit
def pressao(Nx, dx, Ny, dy, u, u_, v, v_, T, p, dt, tol):
    # Cálculo de p
    error = 100
    i     = 0
    while error > tol:
        R_max  = 0
        for i in range(0,Nx):
            for j in range(0,Ny):
                if i == 0 and j == 0:
                    lamda = - (1/(dx**2) + 1/(dy**2))
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((p[i+1,j] - p[i,j])/(dx**2) + (p[i,j+1] - p[i,j])/(dy**2))

                elif i == 0 and j == Ny-1:
                    lamda = - (1.0/dx**2 + 1/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((p[i+1,j] - p[i,j] )/(dx**2) + ( - p[i,j] + p[i,j-1])/(dy**2))

                elif i == Nx-1 and j == 0:
                    lamda = - (1.0/dx**2 + 1/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((- p[i,j] + p[i-1,j])/(dx**2) + (p[i,j+1] - p[i,j])/(dy**2))

                elif i == Nx-1 and j == Ny-1:
                    lamda = - (1.0/dx**2 + 1/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((- p[i,j] + p[i-1,j])/(dx**2) + (- p[i,j] + p[i,j-1])/(dy**2))

                elif i == 0:
                    lamda = - (1.0/dx**2 + 2.0/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((p[i+1,j] - p[i,j])/(dx**2) + (p[i,j+1] - 2.0*p[i,j] + p[i,j-1])/(dy**2))

                elif i == Nx-1:
                    lamda = - (1.0/dx**2 + 2.0/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((- p[i,j] + p[i-1,j])/(dx**2) + (p[i,j+1] - 2.0*p[i,j] + p[i,j-1])/(dy**2))

                elif j == 0:
                    lamda = - (2.0/dx**2 + 1.0/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((p[i+1,j] - 2.0*p[i,j] + p[i-1,j])/(dx**2) + (p[i,j+1] - p[i,j])/(dy**2))

                elif j == Ny-1:
                    lamda = - (2.0/dx**2 + 1.0/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((p[i+1,j] - 2.0*p[i,j] + p[i-1,j])/(dx**2) + (- p[i,j] + p[i,j-1])/(dy**2))

                else:
                    lamda = - (2.0/dx**2 + 2.0/dy**2)
                    R = (u_[i+1,j] - u_[i,j])/(dt*dx) + (v_[i,j+1] - v_[i,j])/(dt*dy)
                    R = R - ((p[i+1,j] - 2.0*p[i,j] + p[i-1,j])/(dx**2) + (p[i,j+1] - 2.0*p[i,j] + p[i,j-1])/(dy**2))

                R = R/lamda
                p[i,j] = p[i,j] + 1.8*R
        i += 1
        R_max = np.abs(R)
        error = R_max
        if i >= 500:
            print('temos um problema')

    # Condições de contorno de pressão
    ## No plano x=0.0 e x=1.0
    p[:,-1] = p[:,0]
    p[:,-2] = p[:,-3]

    ## No plano y=0.0 e y=1.0
    p[-1,:] = p[0,:]
    p[-2,:] = p[-3,:]

    ## Nas pontas
    p[-1,-1]  = p[0,0]
    p[-1,-2]  = p[0,-3]
    p[-2,-1]  = p[-3,0]
    p[-2,-2]  = p[-3,-3]

    return p

# Função para o cálculo de u
@njit
def u_final(Nx, dx, Ny, u, u_, p, dt):
    for i in range(1,Nx-1):
        for j in range(-1,Ny+1):
            u[i,j] = u_[i,j] - dt*((p[i,j] - p[i-1,j])/dx)

    return u

# Função para o cálculo de v
@njit
def v_final(Nx, Ny, dy, v, v_, p, dt):
    for i in range(-1,Nx+1):
        for j in range(1,Ny):
            v[i,j] = v_[i,j] - dt*((p[i,j] - p[i,j-1])/dy)

    return v

# Função para o cálculo da função corrente
@njit
def phi_(Nx, dx, Ny, dy, phi, u, v, tol):
    for i in range(0, Nx+1):
        for j in range(0, Ny+1):
            phi[i, j] = 0

    lamda = -((2 / (dx**2)) + (2/(dy**2)))

    error = 100

    while error > tol:
        R_max = 0
        for i in range(1, Nx):
            for j in range(1, Ny):
                R = -(v[i, j] - v[i-1, j]) / dx + (u[i, j] - u[i, j-1]) / dy -(phi[i+1, j] -2*phi[i, j] + phi[i-1, j]) / (dx**2) -(phi[i, j+1] - 2*phi[i, j] + phi[i, j-1]) / (dy**2)
                R = R / lamda
                phi[i, j] = phi[i, j] + 1.8*R
                if np.abs(R) > R_max:
                    R_max = np.abs(R)

        error = R_max

    return phi

# Função para o cálculo de Nusselt
def Nus(Nx, dx, Ny, T):
    # Criando vetor para receber os valores de Nusselt (Defasada)
    Nu = np.zeros((Ny+2,Nx+2))

    for i in range(0, Nx+1):
        for j in range(0, Ny):
            Nu[i,j] = (T[i,j] - T[i-1,j])/dx

    ## No plano y=0.0 e y=1.0
    Nu[-1,:]  = Nu[0,:]
    Nu[-2,:]  = Nu[-3,:]

    ## Nas pontas
    Nu[-1,-1] = Nu[0,0]
    Nu[-1,-2] = Nu[0,-3]
    Nu[-2,-1] = Nu[-3,0]
    Nu[-2,-2] = Nu[-3,-3]

    # Criando vetor para malha normal
    Mat = np.zeros((Nx+1,Ny+1),float)

    for i in range(0,Nx+1):
        for j in range(0,Ny+1):
            Mat[i,j] = 0.25*(Nu[i,j] + Nu[i-1,j] + Nu[i,j-1] + Nu[i-1,j-1])

    return Mat

# Criar função para pegar o Nusselt no plano y
def Nu_m(Nx, dx, Ny, dy, T):
    # Criando a malha de Nusselt
    Nu   = Nus(Nx, dx, Ny, T)

    # Criando vetor de Nusselt médio
    Nu_m = np.zeros(Nx+1)

    # Nusselt médio em cada plano
    for i in range(0, Nx+1):
        R = 0
        for j in range(0, Ny):
            R += 0.5*dy*(Nu[i,j] + Nu[i,j+1])
        Nu_m[i] = -R

    # Nusselt médio total
    R = 0
    for i in range(Nu_m.shape[0]):
        R += Nu_m[i]

    Nu_barra = R/(Nu_m.shape[0])

    return Nu_m , Nu_barra

"""# Nova seção Para malha 51 x 51, Ra = 1e3, t = 0.5"""

# Divisões da malha e tempo
Nx  = 20
Ny  = 20
Nt  = 0.5

# Tamanho da cavidade
Lx  = 1.0
Ly  = 1.0

# variação em x e y e t
dx  = Lx/Nx
dy  = Ly/Ny
dt  = 1e-4

# Tolerância do modelo
tol = 1e-7

# Número de Prandtl e Rayleigh
Pr  = 0.71
Ra  = 1e3

# Criação das matrizes u, u_, v, v_, p, T
u   = np.zeros((Ny+2,Nx+1), float)
v   = np.zeros((Ny+1,Nx+2), float)

u_  = np.copy(u)
v_  = np.copy(v)

p   = np.zeros((Ny+2,Nx+2),float)

T   = np.copy(p)
T_n = np.copy(p)

# Aplicando as condições de contorno nas faces
T_  = np.ones(Ny+2)

# Calor na face de x=0.0
T[:,-1] = 2.0*T_[:]

filenames_vt = []
filenames_v  = []
filenames_t  = []
cont         = 0
t            = 0

# Começo do loop de tempo
while t < Nt:


################# PASSO 1 #################


    # Cálculo de u*
    u_ = u_prime(Nx, dx, Ny, dy, u, u_, v, dt, Pr)

    # Cálculo de v*
    v_ = v_prime(Nx, dx, Ny, dy, u, v, v_, T, dt, Pr, Ra)


################# PASSO 2 #################


    # Cálculo de Theta
    T = Theta(Nx, dx, Ny, dy, u, v, v_, T, T_n, dt, Pr, Ra)


################# PASSO 3 #################


    # Cálculo da pressão
    p = pressao(Nx, dx, Ny, dy, u, u_, v, v_, T, p, dt, tol)


################# PASSO 4 #################


    # Cálculo de u
    u = u_final(Nx, dx, Ny, u, u_, p, dt)

    # Cálculo de v
    v = v_final(Nx, Ny, dy, v, v_, p, dt)

    cont += 1
    t += dt

    if cont%100 == 0:
        print(f'Simulação {100*(t/Nt):.1f} % completa')

u[int(Nx/2),:]

c = np.abs(np.max(u[int(Nx/2),:]))
c

erro = 100*((3.649 - c)/3.649)
print(f'Erro relativo é de {erro:.2f}%')

v[:,int(Nx/2)]

c = np.abs(np.max(v[:,int(Nx/2)]))
c

erro = 100*((3.697 - c)/3.697)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt na parede aquecida:"""

c= -Nus(Nx, dx, Ny, T)[0]
c

erro = 100*((1.117 - c[0])/1.117)
print(f'Erro relativo é de {erro:.2f}%')

erro = 100*((0.692 - c[-1])/0.692)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt através da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[0]
c

erro = 100*((1.117 - c[0])/1.117)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt médio da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[1]
c

erro = 100*((1.118 - c)/1.118)
print(f'Erro relativo é de {erro:.2f}%')

"""# Nova seção Para malha 51 x 51, Ra = 1e4, t = 0.5"""

# Divisões da malha e tempo
Nx  = 50
Ny  = 50
Nt  = 0.5

# Tamanho da cavidade
Lx  = 1.0
Ly  = 1.0

# variação em x e y e t
dx  = Lx/Nx
dy  = Ly/Ny
dt  = 1e-4

# Tolerância do modelo
tol = 1e-7

# Número de Prandtl e Rayleigh
Pr  = 0.71
Ra  = 1e4

# Criação das matrizes u, u_, v, v_, p, T
u   = np.zeros((Ny+2,Nx+1), float)
v   = np.zeros((Ny+1,Nx+2), float)

u_  = np.copy(u)
v_  = np.copy(v)

p   = np.zeros((Ny+2,Nx+2),float)

T   = np.copy(p)
T_n = np.copy(p)

# Aplicando as condições de contorno nas faces
T_  = np.ones(Ny+2)

# Calor na face de x=0.0
T[:,-1] = 2.0*T_[:]

filenames_vt = []
filenames_v  = []
filenames_t  = []
cont         = 0
t            = 0

# Começo do loop de tempo
while t < Nt:


################# PASSO 1 #################


    # Cálculo de u*
    u_ = u_prime(Nx, dx, Ny, dy, u, u_, v, dt, Pr)

    # Cálculo de v*
    v_ = v_prime(Nx, dx, Ny, dy, u, v, v_, T, dt, Pr, Ra)


################# PASSO 2 #################


    # Cálculo de Theta
    T = Theta(Nx, dx, Ny, dy, u, v, v_, T, T_n, dt, Pr, Ra)


################# PASSO 3 #################


    # Cálculo da pressão
    p = pressao(Nx, dx, Ny, dy, u, u_, v, v_, T, p, dt, tol)


################# PASSO 4 #################


    # Cálculo de u
    u = u_final(Nx, dx, Ny, u, u_, p, dt)

    # Cálculo de v
    v = v_final(Nx, Ny, dy, v, v_, p, dt)

    cont += 1
    t += dt

    if cont%100 == 0:
        print(f'Simulação {100*(t/Nt):.1f} % completa')

u[int(Nx/2),:]

c = np.abs(np.max(u[int(Nx/2),:]))
c

erro = 100*((16.178 - c)/16.178)
print(f'Erro relativo é de {erro:.2f}%')

v[:,int(Nx/2)]

c = np.abs(np.max(v[:,int(Nx/2)]))
c

erro = 100*((19.617 - c)/19.617)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt na parede aquecida:"""

c= -Nus(Nx, dx, Ny, T)[0]
c

erro = 100*((3.528 - c[1])/3.528 )
print(f'Erro relativo é de {erro:.2f}%')

erro = 100*((0.586 - c[-1])/0.586)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt através da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[0]
c

erro = 100*((2.238 - c[0])/2.238)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt médio da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[1]
c

erro = 100*((2.243 - c)/2.243)
print(f'Erro relativo é de {erro:.2f}%')

"""# Nova seção Para malha 51 x 51, Ra = 1e5, t = 0.1"""

# Divisões da malha e tempo
Nx  = 50
Ny  = 50
Nt  = 0.1

# Tamanho da cavidade
Lx  = 1.0
Ly  = 1.0

# variação em x e y e t
dx  = Lx/Nx
dy  = Ly/Ny
dt  = 1e-5

# Tolerância do modelo
tol = 1e-7

# Número de Prandtl e Rayleigh
Pr  = 0.71
Ra  = 1e5

# Criação das matrizes u, u_, v, v_, p, T
u   = np.zeros((Ny+2,Nx+1), float)
v   = np.zeros((Ny+1,Nx+2), float)

u_  = np.copy(u)
v_  = np.copy(v)

p   = np.zeros((Ny+2,Nx+2),float)

T   = np.copy(p)
T_n = np.copy(p)

# Aplicando as condições de contorno nas faces
T_  = np.ones(Ny+2)

# Calor na face de x=0.0
T[:,-1] = 2.0*T_[:]

filenames_vt = []
filenames_v  = []
filenames_t  = []
cont         = 0
t            = 0

# Começo do loop de tempo
while t < Nt:


################# PASSO 1 #################


    # Cálculo de u*
    u_ = u_prime(Nx, dx, Ny, dy, u, u_, v, dt, Pr)

    # Cálculo de v*
    v_ = v_prime(Nx, dx, Ny, dy, u, v, v_, T, dt, Pr, Ra)


################# PASSO 2 #################


    # Cálculo de Theta
    T = Theta(Nx, dx, Ny, dy, u, v, v_, T, T_n, dt, Pr, Ra)


################# PASSO 3 #################


    # Cálculo da pressão
    p = pressao(Nx, dx, Ny, dy, u, u_, v, v_, T, p, dt, tol)


################# PASSO 4 #################


    # Cálculo de u
    u = u_final(Nx, dx, Ny, u, u_, p, dt)

    # Cálculo de v
    v = v_final(Nx, Ny, dy, v, v_, p, dt)

    cont += 1
    t += dt

    if cont%100 == 0:
        print(f'Simulação {100*(t/Nt):.1f} % completa')

u[int(Nx/2),:]

c = np.abs(np.max(u[int(Nx/2),:]))
c

erro = 100*((16.178 - c)/16.178)
print(f'Erro relativo é de {erro:.2f}%')

v[:,int(Nx/2)]

c = np.abs(np.max(v[:,int(Nx/2)]))
c

erro = 100*((19.617 - c)/19.617)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt na parede aquecida:"""

c= -Nus(Nx, dx, Ny, T)[0]
c

erro = 100*((3.528 - c[1])/3.528 )
print(f'Erro relativo é de {erro:.2f}%')

erro = 100*((0.586 - c[-1])/0.586)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt através da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[0]
c

erro = 100*((2.238 - c[0])/2.238)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt médio da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[1]
c

erro = 100*((2.243 - c)/2.243)
print(f'Erro relativo é de {erro:.2f}%')

"""# Nova seção Para malha 51 x 51, Ra = 1e6, t = 0.1"""

# Divisões da malha e tempo
Nx  = 50
Ny  = 50
Nt  = 0.1

# Tamanho da cavidade
Lx  = 1.0
Ly  = 1.0

# variação em x e y e t
dx  = Lx/Nx
dy  = Ly/Ny
dt  = 1e-5

# Tolerância do modelo
tol = 1e-7

# Número de Prandtl e Rayleigh
Pr  = 0.71
Ra  = 1e6

# Criação das matrizes u, u_, v, v_, p, T
u   = np.zeros((Ny+2,Nx+1), float)
v   = np.zeros((Ny+1,Nx+2), float)

u_  = np.copy(u)
v_  = np.copy(v)

p   = np.zeros((Ny+2,Nx+2),float)

T   = np.copy(p)
T_n = np.copy(p)

# Aplicando as condições de contorno nas faces
T_  = np.ones(Ny+2)

# Calor na face de x=0.0
T[:,-1] = 2.0*T_[:]

filenames_vt = []
filenames_v  = []
filenames_t  = []
cont         = 0
t            = 0

# Começo do loop de tempo
while t < Nt:


################# PASSO 1 #################


    # Cálculo de u*
    u_ = u_prime(Nx, dx, Ny, dy, u, u_, v, dt, Pr)

    # Cálculo de v*
    v_ = v_prime(Nx, dx, Ny, dy, u, v, v_, T, dt, Pr, Ra)


################# PASSO 2 #################


    # Cálculo de Theta
    T = Theta(Nx, dx, Ny, dy, u, v, v_, T, T_n, dt, Pr, Ra)


################# PASSO 3 #################


    # Cálculo da pressão
    p = pressao(Nx, dx, Ny, dy, u, u_, v, v_, T, p, dt, tol)


################# PASSO 4 #################


    # Cálculo de u
    u = u_final(Nx, dx, Ny, u, u_, p, dt)

    # Cálculo de v
    v = v_final(Nx, Ny, dy, v, v_, p, dt)

    cont += 1
    t += dt

    if cont%100 == 0:
        print(f'Simulação {100*(t/Nt):.1f} % completa')

u[int(Nx/2),:]

c = np.abs(np.max(u[int(Nx/2),:]))
c

erro = 100*((16.178 - c)/16.178)
print(f'Erro relativo é de {erro:.2f}%')

v[:,int(Nx/2)]

c = np.abs(np.max(v[:,int(Nx/2)]))
c

erro = 100*((19.617 - c)/19.617)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt na parede aquecida:"""

c= -Nus(Nx, dx, Ny, T)[0]
c

erro = 100*((3.528 - c[1])/3.528 )
print(f'Erro relativo é de {erro:.2f}%')

erro = 100*((0.586 - c[-1])/0.586)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt através da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[0]
c

erro = 100*((2.238 - c[0])/2.238)
print(f'Erro relativo é de {erro:.2f}%')

"""Nusselt médio da cavidade:"""

c = Nu_m(Nx, dx, Ny, dy, T)[1]
c

erro = 100*((2.243 - c)/2.243)
print(f'Erro relativo é de {erro:.2f}%')
